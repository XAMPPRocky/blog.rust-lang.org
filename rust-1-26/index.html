<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title></title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="description" content="Empowering everyone to build reliable and efficient software.">
     <!-- Twitter card -->
 <meta name="twitter:card" content="summary">
 <meta name="twitter:site" content="@rustlang">
 <meta name="twitter:creator" content="@rustlang">
 <meta name="twitter:title" content="">
 <meta name="twitter:description" content="">
<meta name="twitter:image" content="https://www.rust-lang.org/static/images/rust-social.jpg">

<!-- Facebook OpenGraph -->
<meta property="og:title" content="" />
<meta property="og:description" content="">
<meta property="og:image" content="https://www.rust-lang.org/static/images/rust-social-wide.jpg" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />

<!-- fonts -->
<link rel="preload" as="font" crossorigin href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;fonts&#x2F;AlfaSlabOne-Regular.ttf">
<link rel="preload" as="font" crossorigin href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;fonts&#x2F;FiraSans-ExtraBold.ttf">
<link rel="preload" as="font" crossorigin href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;fonts&#x2F;FiraSans-ExtraBoldItalic.ttf">
<link rel="preload" as="font" crossorigin href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;fonts&#x2F;FiraSans-Italic.ttf">
<link rel="preload" as="font" crossorigin href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;fonts&#x2F;FiraSans-Italic.ttf">
<link rel="preload" as="font" crossorigin href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;fonts&#x2F;FiraSans-Regular.ttf">
<link rel="preload" as="font" crossorigin href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;fonts&#x2F;FiraSans-SemiBold.ttf">
<link rel="preload" as="font" crossorigin href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;fonts&#x2F;FiraSans-SemiBoldItalic.ttf">

<!-- styles -->
<link rel="stylesheet" href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;styles&#x2F;skeleton.css"/>
<link rel="stylesheet" href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;styles&#x2F;tachyons.css"/>
<link rel="stylesheet" href="xampprocky.github.io&#x2F;blog.rust-lang.org/fonts.css"/>
<link rel="stylesheet" href="xampprocky.github.io&#x2F;blog.rust-lang.org/app.css"/>

<!-- favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;images&#x2F;apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;images&#x2F;favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;images&#x2F;favicon-16x16.png">
<link rel="shortcut icon" href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;images&#x2F;favicon.ico">
<link rel="manifest" href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;images&#x2F;site.webmanifest">
<link rel="mask-icon" color="#5bbad5" href="xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;images&#x2F;safari-pinned-tab.svg">
<meta name="msapplication-TileColor" content="#00aba9">
<meta name="theme-color" content="#ffffff">

 <!-- atom -->
 <link type="application/atom+xml" title="" rel="alternate" href="https://blog.rust-lang.org/feed.xml">

  </head>
  <body>
      <nav class="flex flex-row justify-center justify-end-l items-center flex-wrap ph2 pl3-ns pr4-ns">
          <div class="brand flex-auto w-100 w-auto-l self-start tc tl-l">
              <a href="
xampprocky.github.io&#x2F;blog.rust-lang.org&#x2F;
">
                  <img class="v-mid ml0-l" alt="Rust Logo" src="/images/rust-logo-blk.svg">
                  <span class="dib ml1 ml0-l">Rust Blog</span>
              </a>
          </div>

          <ul class="nav list w-100 w-auto-l flex flex-none flex-row flex-wrap justify-center justify-end-l items-center pv2 ph0 ph4-ns">
              <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org">Rust</a></li>
              <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/tools/install">Install</a></li>
              <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/learn">Learn</a></li>
              <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/tools">Tools</a></li>
              <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/governance">Governance</a></li>
              <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/community">Community</a></li>
          </ul>
      </nav>
      
<section id="Announcing Rust 1.26" class="white">
  <div class="w-100 mw-none ph3 mw8-m mw8-l center f3">
    <header>
      <h2>Announcing Rust 1.26</h2>
      <div class="highlight"></div>
    </header>

    <div class="publish-date-author">May. 10 &middot; The Rust Core Team

    
    </div>

    <div class="post">
      <p>The Rust team is happy to announce a new version of Rust, 1.26.0. Rust is a
systems programming language focused on safety, speed, and concurrency.</p>
<p>If you have a previous version of Rust installed via rustup, getting Rust
1.26.0 is as easy as:</p>
<pre style="background-color:#2b303b;">
<span style="color:#bf616a;">rustup</span><span style="color:#c0c5ce;"> update stable
</span></pre>
<p>If you don't have it already, you can <a href="https://www.rust-lang.org/install.html">get <code>rustup</code></a> from the
appropriate page on our website, and check out the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1260-2018-05-10">detailed release notes for
1.26.0</a> on GitHub.</p>
<h2 id="what-s-in-1-26-0-stable">What's in 1.26.0 stable</h2>
<p>The past few releases have had a steady stream of relatively minor additions. We've
been working on a lot of stuff, however, and it's all starting to land in stable. 1.26 is
possibly the most feature-packed release since Rust 1.0. Let's dig in!</p>
<h4 id="the-rust-programming-language-second-edition">&quot;The Rust Programming Language&quot; Second Edition</h4>
<p>For almost 18 months, Carol, Steve, and others have been working on a
complete re-write of &quot;The Rust Programming Language.&quot; We've learned a lot
about how people learn Rust since the first book was written, and this
version is an improvement in every way.</p>
<p>We've shipped the draft of the second edition on the website for a while now,
but with a disclaimer that it was a work in progress. At this point, the book
is undergoing some final, minor copy-edits, and being prepared for print. As
such, with this release, we are recommending the second edition over the
first. You can <a href="https://doc.rust-lang.org/book/second-edition/">read it on
doc.rust-lang.org</a> or
locally via <code>rustup doc --book</code>.</p>
<p>Speaking of print, you can pre-order a dead tree version of the book <a href="https://www.nostarch.com/Rust">from
NoStarch Press</a>. The contents are identical,
but you get a nice physical book to put on a shelf, or a beautifully typeset
PDF. Proceeds are going to charity.</p>
<h4 id="impl-trait"><code>impl Trait</code></h4>
<p>At long last, <code>impl Trait</code> is here! This feature has been highly desired for
quite a while, and provides a feature known as &quot;existential types.&quot; It's
simpler than that sounds, however. The core of it is this idea:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() -&gt; impl Trait {
    </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>This type signature says &quot;<code>foo</code> is a function that takes no arguments but
returns a type that implements the <code>Trait</code> trait.&quot; That is, we're not
going to tell you what the return type of <code>foo</code> actually is, only that
it implements a particular trait. You may wonder how this differs from
a trait object:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() -&gt; Box&lt;Trait&gt; {
    </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>While it's true that you could have written this code today, it's not
ideal in all situations. Let's say we have a trait <code>Trait</code> that
is implemented for both <code>i32</code> and <code>f32</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">trait </span><span style="color:#c0c5ce;">Trait {
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">method</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">);
}

</span><span style="color:#b48ead;">impl </span><span style="color:#c0c5ce;">Trait </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">i32 {
    </span><span style="color:#65737e;">// implementation goes here
</span><span style="color:#c0c5ce;">}

</span><span style="color:#b48ead;">impl </span><span style="color:#c0c5ce;">Trait </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">f32 {
    </span><span style="color:#65737e;">// implementation goes here
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Consider this function:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() -&gt; ? {
    </span><span style="color:#d08770;">5
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>We want to fill in the return type with something. Previously, only the trait
object version was possible:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() -&gt; Box&lt;Trait&gt; {
    Box::new(</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">) as Box&lt;Trait&gt;
}
</span></pre>
<p>But this introduces a <code>Box</code>, which means allocation. We're not actually
returning some kind of dynamic data here either, so the dynamic dispatch of
the trait object hurts too. So instead, as of Rust 1.26, you can write this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() -&gt; impl Trait {
    </span><span style="color:#d08770;">5
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>This doesn't create a trait object, it's like we had written <code>-&gt; i32</code>, but
instead, we're only mentioning the part about <code>Trait</code>. We get static
dispatch, but we can hide the real type like this.</p>
<p>Why is this useful? One good use is closures. Remember that closures in
Rust all have a unique, un-writable type, yet implement the <code>Fn</code> trait.
This means that if your function returns a closure, you can do this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">// before
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() -&gt; Box&lt;Fn(</span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">) -&gt; </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">&gt; {
    Box::new(|</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">| x + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
}

</span><span style="color:#65737e;">// after
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() -&gt; impl Fn(</span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">) -&gt; </span><span style="color:#b48ead;">i32 </span><span style="color:#c0c5ce;">{
    |x| x + </span><span style="color:#d08770;">1
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>No boxing, no dynamic dispatch. A related scenario happens when returning
iterators. Not only do iterators often include closures, but since they
nest, you get quite deeply nested types. For example:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() {
    vec![</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">]
        .</span><span style="color:#96b5b4;">into_iter</span><span style="color:#c0c5ce;">()
        .</span><span style="color:#96b5b4;">map</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">| x + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
        .</span><span style="color:#96b5b4;">filter</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">| x % </span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">== </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
}
</span></pre>
<p>when compiled, gives this error:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">error[E0308]: mismatched types
 --&gt; src/main.rs:5:5
  |
5 | /     vec![1, 2, 3]
6 | |         .into_iter()
7 | |         .map(|x| x + 1)
8 | |         .filter(|x| x % 2 == 0)
  | |_______________________________^ expected (), found struct `std::iter::Filter`
  |
  = note: expected type `()`
             found type `std::iter::Filter&lt;std::iter::Map&lt;std::vec::IntoIter&lt;{integer}&gt;, [closure@src/main.rs:7:14: 7:23]&gt;, [closure@src/main.rs:8:17: 8:31]&gt;`
</span></pre>
<p>That's a huge 'found type'. Each adapter in the chain adds a new type.
Additionally, we have that closure in there. Previously, we'd have had
to use a trait object here, but now we can simply do</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">() -&gt; impl Iterator&lt;Item = </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">&gt; {
    vec![</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">]
        .</span><span style="color:#96b5b4;">into_iter</span><span style="color:#c0c5ce;">()
        .</span><span style="color:#96b5b4;">map</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">| x + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">)
        .</span><span style="color:#96b5b4;">filter</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">| x % </span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">== </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)
}
</span></pre>
<p>and be done with it. Working with <a href="https://crates.io/crates/futures">futures</a> is very similar.</p>
<p>It's important to note that sometimes trait objects are still
what you need. You can only use <code>impl Trait</code> if your function returns
a single type; if you want to return multiple, you need dynamic dispatch.
For example:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">) -&gt; Box&lt;Iterator&lt;Item = </span><span style="color:#b48ead;">i32</span><span style="color:#c0c5ce;">&gt;&gt; {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> iter = vec![</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">]
        .</span><span style="color:#96b5b4;">into_iter</span><span style="color:#c0c5ce;">()
        .</span><span style="color:#96b5b4;">map</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">| x + </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);

    </span><span style="color:#b48ead;">if</span><span style="color:#c0c5ce;"> x % </span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">== </span><span style="color:#d08770;">0 </span><span style="color:#c0c5ce;">{
        Box::new(iter.</span><span style="color:#96b5b4;">filter</span><span style="color:#c0c5ce;">(|</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">| x % </span><span style="color:#d08770;">2 </span><span style="color:#c0c5ce;">== </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">))
    } </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
        Box::new(iter)
    }
}
</span></pre>
<p>Here, we may return a filtered iterator, or maybe not. There's two different
types that can be returned, and so we must use a trait object.</p>
<p>Oh, and one last thing: to make the syntax a bit more symmetrical, you can
use <code>impl Trait</code> in argument position too. That is:</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">// before
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">&lt;T: Trait&gt;(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: T) {

</span><span style="color:#65737e;">// after
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: impl Trait) {
</span></pre>
<p>which can look a bit nicer for short signatures.</p>
<blockquote>
<p>Side note for you type theorists out there: this isn't an existential, still
a universal. In other words, <code>impl Trait</code> is universal in an input position, but
existential in an output position.</p>
</blockquote>
<h4 id="nicer-match-bindings">Nicer <code>match</code> bindings</h4>
<p>Have you ever had a reference to an <code>Option</code>, and tried to use <code>match</code>? For
example, code like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">hello</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">arg</span><span style="color:#c0c5ce;">: &amp;Option&lt;String&gt;) {
    </span><span style="color:#b48ead;">match</span><span style="color:#c0c5ce;"> arg {
        Some(name) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span style="color:#c0c5ce;">&quot;, name),
        None =&gt; println!(&quot;</span><span style="color:#a3be8c;">I don&#39;t know who you are.</span><span style="color:#c0c5ce;">&quot;),
    }
}
</span></pre>
<p>If you tried to compile this in Rust 1.25, you'd get this error:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">error[E0658]: non-reference pattern used to match a reference (see issue #42640)
 --&gt; src/main.rs:6:9
  |
6 |         Some(name) =&gt; println!(&quot;Hello {}!&quot;, name),
  |         ^^^^^^^^^^ help: consider using a reference: `&amp;Some(name)`

error[E0658]: non-reference pattern used to match a reference (see issue #42640)
 --&gt; src/main.rs:7:9
  |
7 |         None =&gt; println!(&quot;I don&#39;t know who you are.&quot;),
  |         ^^^^ help: consider using a reference: `&amp;None`
</span></pre>
<p>Okay, sure. Let's modify the code:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">hello</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">arg</span><span style="color:#c0c5ce;">: &amp;Option&lt;String&gt;) {
    </span><span style="color:#b48ead;">match</span><span style="color:#c0c5ce;"> arg {
        &amp;Some(name) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span style="color:#c0c5ce;">&quot;, name),
        &amp;None =&gt; println!(&quot;</span><span style="color:#a3be8c;">I don&#39;t know who you are.</span><span style="color:#c0c5ce;">&quot;),
    }
}
</span></pre>
<p>We added the <code>&amp;</code>s the compiler complained about. Let's try to compile again:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |         &amp;Some(name) =&gt; println!(&quot;Hello {}!&quot;, name),
  |         ^^^^^^----^
  |         |     |
  |         |     hint: to prevent move, use `ref name` or `ref mut name`
  |         cannot move out of borrowed content
</span></pre>
<p>Okay, sure. Let's make the compiler happy again by taking its advice:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">hello</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">arg</span><span style="color:#c0c5ce;">: &amp;Option&lt;String&gt;) {
    </span><span style="color:#b48ead;">match</span><span style="color:#c0c5ce;"> arg {
        &amp;Some(</span><span style="color:#b48ead;">ref</span><span style="color:#c0c5ce;"> name) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span style="color:#c0c5ce;">&quot;, name),
        &amp;None =&gt; println!(&quot;</span><span style="color:#a3be8c;">I don&#39;t know who you are.</span><span style="color:#c0c5ce;">&quot;),
    }
}
</span></pre>
<p>This will finally compile. We had to add two <code>&amp;</code>s, and a <code>ref</code>. But more
importantly, none of this was really <em>helpful</em> to us as programmers. Sure,
we forgot a <code>&amp;</code> at first, but does that matter? We had to add <code>ref</code> to
get a reference to the inside of the option, but we couldn't do anything <em>but</em>
get a reference, as we can't move out of a <code>&amp;T</code>.</p>
<p>So, as of Rust 1.26, the initial code, without the <code>&amp;</code>s and <code>ref</code>, will just
compile and do exactly what you'd expect. In short, the compiler will automatically
reference or de-reference in <code>match</code> statements. So when we say</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">    </span><span style="color:#b48ead;">match</span><span style="color:#c0c5ce;"> arg {
        Some(name) =&gt; println!(&quot;</span><span style="color:#a3be8c;">Hello </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">!</span><span style="color:#c0c5ce;">&quot;, name),
</span></pre>
<p>the compiler automatically references the <code>Some</code>, and since we're borrowing,
<code>name</code> is bound as <code>ref name</code> automatically as well. If we were mutating:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">hello</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">arg</span><span style="color:#c0c5ce;">: &amp;</span><span style="color:#b48ead;">mut </span><span style="color:#c0c5ce;">Option&lt;String&gt;) {
    </span><span style="color:#b48ead;">match</span><span style="color:#c0c5ce;"> arg {
        Some(name) =&gt; name.</span><span style="color:#96b5b4;">push_str</span><span style="color:#c0c5ce;">(&quot;</span><span style="color:#a3be8c;">, world</span><span style="color:#c0c5ce;">&quot;),
        None =&gt; (),
    }
}
</span></pre>
<p>the compiler will automatically borrow by mutable reference, and <code>name</code> will
be bound as <code>ref mut</code> too.</p>
<p>We think this will remove a significant papercut for new and old Rustaceans
alike. The compiler will just do the right thing more often without the need
for boilerplate.</p>
<h4 id="main-can-return-a-result"><code>main</code> can return a <code>Result</code></h4>
<p>Speaking of papercuts, since Rust uses the <code>Result</code> type for returning
errors, and <code>?</code> to make handling them easy, a common pain-point of
new Rustaceans is to try and use <code>?</code> in <code>main</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">std::fs::File;

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> f = File::open(&quot;</span><span style="color:#a3be8c;">bar.txt</span><span style="color:#c0c5ce;">&quot;)?;
}
</span></pre>
<p>This will give an error like &quot;error[E0277]: the <code>?</code> operator can only be used
in a function that returns <code>Result</code>&quot;. This leads to a pattern where many
people write code that <a href="https://doc.rust-lang.org/book/second-edition/ch12-03-improving-error-handling-and-modularity.html#extracting-logic-from-main">looks like this</a>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">run</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">config</span><span style="color:#c0c5ce;">: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    </span><span style="color:#65737e;">// --snip--
</span><span style="color:#c0c5ce;">}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#65737e;">// --snip--

    </span><span style="color:#b48ead;">if let </span><span style="color:#c0c5ce;">Err(e) = </span><span style="color:#96b5b4;">run</span><span style="color:#c0c5ce;">(config) {
        println!(&quot;</span><span style="color:#a3be8c;">Application error: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, e);

        process::exit(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">);
    }
}
</span></pre>
<p>Our <code>run</code> function has all of the real logic, and <code>main</code>
calls <code>run</code>, only checking to see if there was an error
and exiting. We need to make this second function because
<code>main</code> can't return a <code>Result</code>, but we'd like to use <code>?</code>
in that logic.</p>
<p>In Rust 1.26, you can now declare <code>main</code> that returns <code>Result</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">std::fs::File;

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() -&gt; Result&lt;(), std::io::Error&gt; {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> f = File::open(&quot;</span><span style="color:#a3be8c;">bar.txt</span><span style="color:#c0c5ce;">&quot;)?;

    Ok(())
}
</span></pre>
<p>This now works just fine! If <code>main</code> returns an error, this will
exit with an error code, and print out a debug representation
of the error.</p>
<h4 id="inclusive-ranges-with">Inclusive ranges with <code>..=</code></h4>
<p>Since well before Rust 1.0, you've been able to create exclusive ranges with <code>..</code>
like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">for</span><span style="color:#c0c5ce;"> i in </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">..</span><span style="color:#d08770;">3 </span><span style="color:#c0c5ce;">{
    println!(&quot;</span><span style="color:#a3be8c;">i: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, i);
}
</span></pre>
<p>This will print <code>i: 1</code> and then <code>i: 2</code>. In Rust 1.26, you can now create an
inclusive range, like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">for</span><span style="color:#c0c5ce;"> i in </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">..=</span><span style="color:#d08770;">3 </span><span style="color:#c0c5ce;">{
    println!(&quot;</span><span style="color:#a3be8c;">i: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, i);
}
</span></pre>
<p>This will print <code>i: 1</code> and then <code>i: 2</code> like before, but also <code>i: 3</code>; the
three is included in the range. Inclusive ranges are especially useful
if you want to iterate over every possible value in a range. For example,
this is a surprising Rust program:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">takes_u8</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">) {
    </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">for</span><span style="color:#c0c5ce;"> i in </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">..</span><span style="color:#d08770;">256 </span><span style="color:#c0c5ce;">{
        println!(&quot;</span><span style="color:#a3be8c;">i: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, i);
        </span><span style="color:#96b5b4;">takes_u8</span><span style="color:#c0c5ce;">(i);
    }
}
</span></pre>
<p>What does this program do? The answer: nothing. The warning we get when
compiling has a hint:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">warning: literal out of range for u8
 --&gt; src/main.rs:6:17
  |
6 |     for i in 0..256 {
  |                 ^^^
  |
  = note: #[warn(overflowing_literals)] on by default
</span></pre>
<p>That's right, since <code>i</code> is a <code>u8</code>, this overflows, and is the same as writing
<code>for i in 0..0</code>, so the loop executes zero times.</p>
<p>We can do this with inclusive ranges, however:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">takes_u8</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">x</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">) {
    </span><span style="color:#65737e;">// ...
</span><span style="color:#c0c5ce;">}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">for</span><span style="color:#c0c5ce;"> i in </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">..=</span><span style="color:#d08770;">255 </span><span style="color:#c0c5ce;">{
        println!(&quot;</span><span style="color:#a3be8c;">i: </span><span style="color:#d08770;">{}</span><span style="color:#c0c5ce;">&quot;, i);
        </span><span style="color:#96b5b4;">takes_u8</span><span style="color:#c0c5ce;">(i);
    }
}
</span></pre>
<p>This will produce those 256 lines of output you might have been expecting.</p>
<h4 id="basic-slice-patterns">Basic slice patterns</h4>
<p>Another long-awaited feature is &quot;slice patterns.&quot; These let you match on
slices similar to how you match on other data types. For example:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> arr = [</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">];

</span><span style="color:#b48ead;">match</span><span style="color:#c0c5ce;"> arr {
    [</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">, _, _] =&gt; &quot;</span><span style="color:#a3be8c;">starts with one</span><span style="color:#c0c5ce;">&quot;,
    [a, b, c] =&gt; &quot;</span><span style="color:#a3be8c;">starts with something else</span><span style="color:#c0c5ce;">&quot;,
}
</span></pre>
<p>In this case, we know <code>arr</code> has a length of three, and so we need three entries
inside the <code>[]</code>s. We can also match when we don't know the length:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">foo</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">s</span><span style="color:#c0c5ce;">: &amp;[</span><span style="color:#b48ead;">u8</span><span style="color:#c0c5ce;">]) {
    </span><span style="color:#b48ead;">match</span><span style="color:#c0c5ce;"> s {
        [a, b] =&gt; (),
        [a, b, c] =&gt; (),
        _ =&gt; (),
    }
}
</span></pre>
<p>Here, we don't know how long <code>s</code> is, so we can write the first two arms, each with
different lengths. This also means we need a <code>_</code> term, since we aren't covering
every possible length, nor could we!</p>
<h4 id="speed-improvements">Speed improvements</h4>
<p>We continue to work on the speed of the compiler. We discovered that deeply
nesting types was non-linear in some cases, and <a href="https://github.com/rust-lang/rust/pull/48296">a fix was
implemented</a>. We're seeing up
to a 12% reduction in compile times from this change, but many other smaller
fixes landed as well. More to come in the future!</p>
<h4 id="128-bit-integers">128 bit integers</h4>
<p>Finally, a very simple feature: Rust now has 128 bit integers!</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> x: i128 = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> y: u128 = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
</span></pre>
<p>These are twice the size of <code>u64</code>, and so can hold more values. More specifically,</p>
<ul>
<li><code>u128</code>: 0 - 340,282,366,920,938,463,463,374,607,431,768,211,455</li>
<li><code>i128</code>: −170,141,183,460,469,231,731,687,303,715,884,105,728 - 170,141,183,460,469,231,731,687,303,715,884,105,727</li>
</ul>
<p>Whew!</p>
<p>See the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1260-2018-05-10">detailed release notes</a> for more.</p>
<h3 id="library-stabilizations">Library stabilizations</h3>
<p>We stabilized <a href="https://doc.rust-lang.org/std/fs/fn.read_to_string.html"><code>fs::read_to_string</code></a>,
a convenience over <code>File::open</code> and <code>io::Read::read_to_string</code> for easily reading an entire
file into memory at once:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">std::fs;
</span><span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">std::net::SocketAddr;

</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> foo: SocketAddr = fs::read_to_string(&quot;</span><span style="color:#a3be8c;">address.txt</span><span style="color:#c0c5ce;">&quot;)?.</span><span style="color:#96b5b4;">parse</span><span style="color:#c0c5ce;">()?;
</span></pre>
<p>You can now <a href="https://github.com/rust-lang/rust/pull/48978">format numbers as hexadecimal with <code>Debug</code>
formatting</a>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">assert!(format!(&quot;</span><span style="color:#a3be8c;">{:02x?}</span><span style="color:#c0c5ce;">&quot;, </span><span style="color:#b48ead;">b</span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">Foo</span><span style="color:#96b5b4;">\0</span><span style="color:#c0c5ce;">&quot;) == &quot;</span><span style="color:#a3be8c;">[46, 6f, 6f, 00]</span><span style="color:#c0c5ce;">&quot;)
</span></pre>
<p>Trailing commas <a href="https://github.com/rust-lang/rust/pull/48056">are now supported by all macros in the standard
library</a>.</p>
<p>See the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1260-2018-05-10">detailed release notes</a> for more.</p>
<h3 id="cargo-features">Cargo features</h3>
<p>Cargo didn't receive many big new features this release but rather saw a steady
stream of stability and performance improvements. Cargo should now resolve lock
files even faster, backtrack more intelligently, and require manual <code>cargo update</code> invocations less. Cargo's binary <a href="https://github.com/rust-lang/cargo/pull/5083">now also shares the same version as
<code>rustc</code></a>.</p>
<p>See the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1260-2018-05-10">detailed release notes</a> for more.</p>
<h2 id="contributors-to-1-26-0">Contributors to 1.26.0</h2>
<p>Many people came together to create Rust 1.26. We couldn't have done it
without all of you.</p>
<p><a href="https://thanks.rust-lang.org/rust/1.26.0">Thanks!</a></p>

    </div>
  </div>
</section>

      <footer>
  <div class="w-100 mw-none ph3 mw8-m mw9-l center f3">
    <div class="row">
      <div class="four columns mt3 mt0-l" id="get-help">
        <h4>Get help!</h4>
        <ul>
          <li><a href="https://doc.rust-lang.org" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="mailto:core-team@rust-lang.org">Contact the Rust Team</a></li>
          <li><a href="http://ping.rust-lang.org">Check Website Status</a></li>
        </ul>
      </div>
      <div class="four columns mt3 mt0-l">
        <h4>Terms and policies</h4>
        <ul>
          <li><a href="https://www.rust-lang.org/policies/code-of-conduct">Code of Conduct</a></li>
          <li><a href="https://www.rust-lang.org/policies/licenses">Licenses</a></li>
          <li><a href="https://www.rust-lang.org/policies/media-guide">Logo Policy and Media Guide</a></li>
          <li><a href="https://www.rust-lang.org/policies/security">Security Disclosures</a></li>
          <li><a href="https://www.rust-lang.org/policies">All Policies</a></li>
        </ul>
      </div>
      <div class="four columns mt3 mt0-l">
        <h4>Social</h4>
        <a href="https://twitter.com/rustlang" target="_blank" rel="noopener" alt="twitter link"><img src="/images/twitter.svg" alt="twitter logo" title="Twitter"/></a>
        <a href="https://www.youtube.com/channel/UCaYhcUwRBNscFNUKTjgPFiA" target="_blank" rel="noopener" alt="youtube link"><img style="padding-top: 6px; padding-bottom:6px" src="/images/youtube.svg" alt="youtube logo" title="YouTube"/></a>
        <a href="https://discord.gg/rust-lang" target="_blank" rel="noopener" alt="discord link"><img src="/images/discord.svg" alt="discord logo" title="Discord"/></a>
        <a href="https://github.com/rust-lang" target="_blank" rel="noopener" alt="github link"><img src="/images/github.svg" alt="github logo" title="GitHub"/></a>
      </div>

    </div>
    <div class="attribution">
      Maintained by the Rust Team. See a typo?
      <a href="https://github.com/rust-lang/blog.rust-lang.org" target="_blank" rel="noopener">Send a fix here</a>!
    </div>
  </div>
</footer>

<!-- scripts -->
<script src="/scripts/highlight.js"></script>

  </body>
</html>
